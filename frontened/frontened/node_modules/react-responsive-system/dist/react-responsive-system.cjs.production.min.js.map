{"version":3,"file":"react-responsive-system.cjs.production.min.js","sources":["../src/merge.ts","../src/omit.ts","../src/index.tsx"],"sourcesContent":["import deepMerge from 'deepmerge';\n\ntype MergeArrayHelpers = deepMerge.Options & {\n  cloneUnlessOtherwiseSpecified: <T>(item: T, options: MergeArrayHelpers) => T;\n  isMergeableObject: <T>(item: T) => boolean;\n};\n\nfunction mergeArrays(base: any[], override: any[], helpers: MergeArrayHelpers) {\n  const { cloneUnlessOtherwiseSpecified, isMergeableObject } = helpers;\n\n  // clone the target array\n  const final = [...base];\n\n  override.forEach((overrideItem, index) => {\n    const baseItem = base[index];\n\n    if (isMergeableObject(overrideItem)) {\n      // if we encounter a \"mergeable\" object, merge it with the base item\n      /* eslint-disable @typescript-eslint/no-use-before-define */\n      final[index] = mergeTwo(baseItem, overrideItem);\n    } else {\n      // otherwise just replace whatever was in the base array with the override\n      final[index] = cloneUnlessOtherwiseSpecified(overrideItem, helpers);\n    }\n  });\n\n  return final;\n}\n\nfunction mergeTwo<P extends {}>(base: Partial<P>, override: Partial<P>) {\n  return deepMerge(base, override, { arrayMerge: mergeArrays });\n}\n\nexport function merge<P extends {}>(propsObjects: Partial<P>[]) {\n  return deepMerge.all<P>(propsObjects, { arrayMerge: mergeArrays });\n}\n","/**\n * Omits the given keys from the given object\n */\nexport function omit<T extends { [key: string]: any }, K extends keyof T>(\n  obj: T,\n  omittedKeys: K[],\n): Omit<T, K> {\n  // TypeScript assigns the return type, string[] - we are asserting that the return type keyof T\n  const allKeys = Object.keys(obj) as (keyof T)[];\n\n  return allKeys.reduce<Partial<Omit<T, K>>>((acc, key) => {\n    // `omittedKeys.indexOf` expects an input of type K extends keyof T\n    // `key` is type keyof T, but for some reason TypeScript is freaking out\n    // idk.\n    const shouldOmit = omittedKeys.indexOf(key as K) !== -1;\n\n    if (!shouldOmit) {\n      // assert that if we got this far, `key` must be one of the keys that _does not_ exist in K\n      const keptKey = key as Exclude<keyof T, K>;\n\n      acc[keptKey] = obj[keptKey];\n    }\n\n    return acc;\n    // assert that the output is exactly Omit<T, K> rather than Partial<Omit<T, K>>\n  }, {}) as Omit<T, K>;\n}\n","import * as React from 'react';\nimport { merge } from './merge';\nimport { omit } from './omit';\n\n//\n// ─── HELPERS ────────────────────────────────────────────────────────────────────\n//\n\n// keep track of whether or not we have access to `window` (so that we don't crash during e.g. server-side rendering)\nconst windowExists = typeof window === 'object';\n\n//\n// ─── TYPES ──────────────────────────────────────────────────────────────────────\n//\n\n/**\n * A mapping of ScreenClass names to the maximum pixel-width where they apply\n *\n * Of course, your largest breakpoint will not have a maximum pixel-width--pass `Infinity` in order to indicate that there's no maximum.\n * Every instance of ScreenClassBreakpoints should have exactly one ScreenClass with a value of `Infinity`,\n * otherwise very-large screen sizes will manifest as having an `undefined` ScreenClass\n *\n * @example\n * {\n *   xs: 500, // 0 - 500px -> \"xs\"\n *   sm: 750, // 501 - 750px -> \"sm\"\n *   md: 1000, // 751 - 1000px -> \"md\"\n *   lg: Infinity, // 1001+ -> \"lg\"\n * }\n */\nexport type ScreenClassBreakpoints = {\n  [screenClass: string]: number;\n};\n\nexport type ScreenClassConfiguration<B extends ScreenClassBreakpoints> = {\n  /**\n   * The ScreenClass that should be used if we're unable to determine the size of the window\n   * (i.e. when `window` does not exist e.g. during server-side rendering or headless testing)\n   *\n   * Tip: during testing, use this prop to control the ScreenClass for a given test\n   */\n  defaultScreenClass: keyof B;\n\n  /**\n   * A mapping of ScreenClass names to the maximum pixel-width where they apply\n   *\n   * @example\n   * {\n   *   xs: 500,\n   *   sm: 750,\n   *   md: 1000,\n   *   lg: Infinity\n   * }\n   */\n  breakpoints: B;\n\n  /**\n   * Controls the way that overrides are applied\n   *\n   * \"no-cascade\" -> only apply overrides on the exact screen class\n   * \"mobile-first\" -> override on matching screen class and larger\n   * \"desktop-first\" -> override on matching screen class and smaller\n   *\n   * @default \"no-cascade\"\n   */\n  cascadeMode?: 'no-cascade' | 'mobile-first' | 'desktop-first';\n};\n\nexport type ScreenClass<B extends ScreenClassBreakpoints> = keyof B;\n\nexport type ResponsiveProps<B extends ScreenClassBreakpoints, P extends {}> = Omit<P, keyof B> &\n  {\n    [K in keyof B]?: Partial<P> | ((baseProps: P) => P);\n  };\n\n//\n// ─── FACTORY ────────────────────────────────────────────────────────────────────\n//\n\nexport function createResponsiveSystem<B extends ScreenClassBreakpoints>(\n  screenClassConfiguration: ScreenClassConfiguration<B>,\n) {\n  const { defaultScreenClass, breakpoints, cascadeMode = 'no-cascade' } = screenClassConfiguration;\n\n  //\n  // ─── VALIDATE ───────────────────────────────────────────────────────────────────\n  //\n\n  // optimize these error-checks out of production builds\n  if (__DEV__) {\n    // todo: validate that defaultScreenClass is defined or that breakpoints is an object?\n    // how much should we assume based on our Types?\n\n    const breakpointValues = Object.values(breakpoints);\n    if (breakpointValues.length < 2) {\n      throw new Error(\n        'ScreenClassConfigurationError - `breakpoints` must have at least 2 keys e.g. `{ mobile: 320, desktop: Infinity }`',\n      );\n    }\n\n    if (breakpointValues.filter((value) => value === Infinity).length !== 1) {\n      throw new Error(\n        'ScreenClassConfigurationError - `breakpoints` must have exactly 1 entry with a value of `Infinity` for the maximum pixel-width e.g. `{ mobile: 320, desktop: Infinity }`',\n      );\n    }\n  }\n\n  //\n  // ─── SORT ───────────────────────────────────────────────────────────────────────\n  //\n\n  // sort the screen classes from smallest -> largest (will make it easier to determine the proper screen class given a window-width later)\n  const sortedScreenClassBreakpoints: [keyof B, number][] = Object.entries(\n    breakpoints,\n    // we don't need the first value in the tuples, so we leave that slot empty\n    // it looks a bit odd, but it's correct and doesn't introduce additional variables that we won't use\n  ).sort(([, maxPixelWidth1], [, maxPixelWidth2]) => {\n    return maxPixelWidth1 > maxPixelWidth2 ? 1 : 0;\n  });\n\n  const sortedScreenClasses = sortedScreenClassBreakpoints.map(([screenClass]) => screenClass);\n\n  /**\n   * Mobile-First Screen Classes include the current screen class and all smaller\n   *\n   * They should be applied smallest to largest\n   */\n  function getMobileFirstScreenClasses(breakpoint: keyof B) {\n    return sortedScreenClasses.slice(0, sortedScreenClasses.indexOf(breakpoint) + 1);\n  }\n\n  /**\n   * Desktop-First Screen Classes include the current screen class and all larger\n   *\n   * They should be applied from largest to smallest\n   */\n  function getDesktopFirstScreenClasses(breakpoint: keyof B) {\n    return sortedScreenClasses.slice(sortedScreenClasses.indexOf(breakpoint)).reverse();\n  }\n\n  //\n  // ─── CONTEXT ────────────────────────────────────────────────────────────────────\n  //\n\n  const screenClassContext = React.createContext<ScreenClass<B> | undefined>(undefined);\n\n  //\n  // ─── PROVIDER ───────────────────────────────────────────────────────────────────\n  //\n\n  const { Provider } = screenClassContext;\n\n  const ScreenClassProvider: React.FC = ({ children }) => {\n    const [screenClass, setScreenClass] = React.useState<keyof B>(defaultScreenClass);\n\n    React.useLayoutEffect(() => {\n      if (!windowExists) {\n        return;\n      }\n\n      // build the media queries\n      const screenClassMediaQueries: [keyof B, MediaQueryList][] = sortedScreenClassBreakpoints.map(\n        ([screenClass, maxWidthPx], index) => {\n          // the minWidth for this screenClass is the maxWidth of the previous breakpoint + 1\n          const minWidthPx = index > 0 ? sortedScreenClassBreakpoints[index - 1][1] + 1 : 0;\n\n          const constraints: string[] = [];\n          if (minWidthPx !== 0) {\n            constraints.push(`(min-width: ${minWidthPx}px)`);\n          }\n          if (maxWidthPx !== Infinity) {\n            constraints.push(`(max-width: ${maxWidthPx}px)`);\n          }\n\n          const mediaQuery = constraints.join(' and ');\n\n          const mediaQueryList = window.matchMedia(mediaQuery);\n\n          // in order to set the correct initial state, we need to immediately check each mql\n          if (mediaQueryList.matches) {\n            setScreenClass(screenClass);\n          }\n\n          return [screenClass, mediaQueryList];\n        },\n      );\n\n      type MediaQueryListListener = (this: MediaQueryList, event: MediaQueryListEvent) => any;\n\n      const listeners: [MediaQueryList, MediaQueryListListener][] = [];\n      screenClassMediaQueries.forEach(([screenClass, mediaQuery]) => {\n        const listener: MediaQueryListListener = (event) => {\n          if (event.matches) {\n            setScreenClass(screenClass);\n          }\n        };\n\n        mediaQuery.addListener(listener);\n\n        listeners.push([mediaQuery, listener]);\n      });\n\n      return () => listeners.forEach(([mql, l]) => mql.removeListener(l));\n    }, []);\n\n    return <Provider value={screenClass}>{children}</Provider>;\n  };\n\n  function useScreenClass(): keyof B {\n    const screenClass = React.useContext(screenClassContext);\n\n    if (screenClass === undefined) {\n      // optimize this error-check out of production builds\n      if (__DEV__) {\n        throw new Error(\n          \"`useScreenClass` may only be used inside of a ScreenClassProvider. Make sure that you've rendered a ScreenClassProvider above this component your tree (usually folks render ScreenClassProvider near the root of their app). Returning the default screen class.\",\n        );\n      }\n\n      return defaultScreenClass;\n    }\n\n    return screenClass;\n  }\n\n  function useResponsiveProps<P extends {}>(props: ResponsiveProps<B, P>): P {\n    const currentScreenClass = React.useContext(screenClassContext);\n\n    if (currentScreenClass === undefined) {\n      // optimize this error-check out of production builds\n      if (__DEV__) {\n        throw new Error(\n          \"`useResponsiveProps` may only be used inside of a ScreenClassProvider. Make sure that you've rendered a ScreenClassProvider above this component your tree (usually folks render ScreenClassProvider near the root of their app). Returning the default props with no overrides.\",\n        );\n      }\n\n      // if there's no screenClassContext, we'll just return the default props with no overrides\n      // TypeScript: this is correct, but TS is having trouble confirming that it will be type P\n      return omit(props, sortedScreenClasses) as P;\n    }\n\n    //\n    // ─── DETERMINE PROPS ─────────────────────────────────────────────\n    //\n\n    // TypeScript: this is correct, but TS is having trouble confirming that it will be type P\n    const baseProps = omit(props, sortedScreenClasses) as P;\n\n    let applicableScreenClasses = [];\n    switch (cascadeMode) {\n      case 'mobile-first':\n        applicableScreenClasses = getMobileFirstScreenClasses(currentScreenClass);\n        break;\n      case 'desktop-first':\n        applicableScreenClasses = getDesktopFirstScreenClasses(currentScreenClass);\n        break;\n      case 'no-cascade':\n      default:\n        applicableScreenClasses = [currentScreenClass];\n    }\n\n    // apply each screen class on top of the baseProps\n    // the screenClasses should be sorted in the order in which they should be applied\n    // e.g. mobile-first should apply smallest -> largest\n    // e.g. desktop-first should apply largest -> smallest\n    // we assume that the sorting is already done\n    const propsToMerge = [baseProps, ...applicableScreenClasses.map((sc) => props[sc] ?? {})];\n    return merge(propsToMerge);\n  }\n\n  // In order to support refs, we need to use forwardRef\n  // but technically refs can't be forwarded to Function Components\n  // so we produce overloaded signatures so that TS will yell at folks\n  // who try to use the ref prop if they passed us a Function Component\n  // our implementation will always pass the ref to the given component (even if it's a Function Component)\n  // but React won't complain about it if the ref is undefined.\n  // It's not possible (afaik) to detect a Function Component vs ForwardRef vs Class\n  // so we can't dynamically call forwardRef depending on that context\n  // so we're relying on TS overrides to block devs from defining the ref\n  // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/35834\n\n  // Host Components (e.g. \"div\") have refs defined by JSX.IntrinsicElements\n  // @ts-ignore\n  function responsive<K extends keyof JSX.IntrinsicElements>(\n    Component: K,\n  ): React.ForwardRefExoticComponent<ResponsiveProps<B, JSX.IntrinsicElements[K]>>;\n\n  // Class Component refs hold the instance of the class\n  function responsive<T extends React.ComponentClass<any>>(\n    Component: T,\n  ): React.ForwardRefExoticComponent<\n    ResponsiveProps<B, React.ComponentPropsWithoutRef<T> & { ref?: React.Ref<InstanceType<T>> }>\n  >;\n\n  // ForwardRef Components have a ref as a prop\n  function responsive<P extends { ref?: React.Ref<any> }>(\n    Component: React.ForwardRefExoticComponent<P>,\n  ): React.ForwardRefExoticComponent<ResponsiveProps<B, P>>;\n\n  // Function Components don't have refs\n  function responsive<P>(\n    Component: React.FunctionComponent<P>,\n  ): React.ForwardRefExoticComponent<ResponsiveProps<B, P>>;\n\n  // Implementation - just forwardRef to everything\n  function responsive<P>(Component: React.ComponentType<P>) {\n    // @ts-ignore\n    const ResponsiveComponent = React.forwardRef((props: ResponsiveProps<B, P>, ref) => {\n      const responsiveProps = useResponsiveProps<P>(props);\n\n      return <Component ref={ref} {...responsiveProps} />;\n    });\n\n    ResponsiveComponent.displayName =\n      Component.displayName !== undefined\n        ? `Responsive(${Component.displayName})`\n        : 'ResponsiveComponent';\n\n    return ResponsiveComponent;\n  }\n\n  return {\n    ScreenClassProvider,\n    useResponsiveProps,\n    useScreenClass,\n    responsive,\n  };\n}\n"],"names":["mergeArrays","base","override","helpers","cloneUnlessOtherwiseSpecified","isMergeableObject","final","forEach","overrideItem","index","baseItem","deepMerge","arrayMerge","mergeTwo","omit","obj","omittedKeys","Object","keys","reduce","acc","key","indexOf","windowExists","window","screenClassConfiguration","defaultScreenClass","cascadeMode","sortedScreenClassBreakpoints","entries","breakpoints","sort","sortedScreenClasses","map","screenClassContext","React","undefined","Provider","useResponsiveProps","props","currentScreenClass","baseProps","applicableScreenClasses","slice","breakpoint","reverse","getDesktopFirstScreenClasses","propsToMerge","sc","all","ScreenClassProvider","children","screenClass","setScreenClass","screenClassMediaQueries","maxWidthPx","minWidthPx","constraints","push","Infinity","mediaQuery","join","mediaQueryList","matchMedia","matches","listeners","listener","event","addListener","removeListener","value","useScreenClass","responsive","Component","ResponsiveComponent","ref","responsiveProps","displayName"],"mappings":"uKAOA,SAASA,EAAYC,EAAaC,EAAiBC,OACzCC,EAAqDD,EAArDC,8BAA+BC,EAAsBF,EAAtBE,kBAGjCC,YAAYL,UAElBC,EAASK,SAAQ,SAACC,EAAcC,OACxBC,EAAWT,EAAKQ,GAKpBH,EAAMG,GAHJJ,EAAkBG,GAa1B,SAAgCP,EAAkBC,UACzCS,EAAUV,EAAMC,EAAU,CAAEU,WAAYZ,IAX5Ba,CAASH,EAAUF,GAGnBJ,EAA8BI,EAAcL,MAIxDG,WCvBOQ,EACdC,EACAC,UAGgBC,OAAOC,KAAKH,GAEbI,QAA4B,SAACC,EAAKC,UAIO,IAAnCL,EAAYM,QAAQD,KAMrCD,EAFgBC,GAEDN,EAFCM,IAKXD,IAEN,IChBL,IAAMG,EAAiC,iBAAXC,+CAuE1BC,OAEQC,EAAgED,EAAhEC,qBAAgED,EAA/BE,YAAAA,aAAc,eA8BjDC,EAAoDX,OAAOY,QA9BOJ,EAA5CK,aAkC1BC,MAAK,+BACoC,EAAI,KAGzCC,EAAsBJ,EAA6BK,KAAI,2BAwBvDC,EAAqBC,qBAAgDC,GAMnEC,EAAaH,EAAbG,kBA2ECC,EAAiCC,OAClCC,EAAqBL,aAAiBD,WAEjBE,IAAvBI,SAUK1B,EAAKyB,EAAOP,OAQfS,EAAY3B,EAAKyB,EAAOP,GAE1BU,EAA0B,UACtBf,OACD,eACHe,EA3HGV,EAAoBW,MAAM,EAAGX,EAAoBV,QA2HEkB,GA3HoB,aA6HvE,gBACHE,WAtHgCE,UAC7BZ,EAAoBW,MAAMX,EAAoBV,QAAQsB,IAAaC,UAqH5CC,CAA6BN,aAEpD,qBAEHE,EAA0B,CAACF,OAQzBO,GAAgBN,UAAcC,EAAwBT,KAAI,SAACe,yBAAOT,EAAMS,MAAO,cFxOhFrC,EAAUsC,IEyOFF,EFzOuB,CAAEnC,WAAYZ,UE+R7C,CACLkD,oBA1KoC,gBAAGC,IAAAA,WACDhB,WAAwBT,GAAvD0B,OAAaC,cAEpBlB,mBAAsB,cACfZ,OAKC+B,EAAuD1B,EAA6BK,KACxF,WAA4BxB,OAA1B2C,OAAaG,OAEPC,EAAa/C,EAAQ,EAAImB,EAA6BnB,EAAQ,GAAG,GAAK,EAAI,EAE1EgD,EAAwB,GACX,IAAfD,GACFC,EAAYC,oBAAoBF,SAEfG,WAAfJ,GACFE,EAAYC,oBAAoBH,aAG5BK,EAAaH,EAAYI,KAAK,SAE9BC,EAAiBtC,OAAOuC,WAAWH,UAGrCE,EAAeE,SACjBX,EAAeD,GAGV,CAACA,EAAaU,MAMnBG,EAAwD,UAC9DX,EAAwB/C,SAAQ,gBAAE6C,OAAaQ,OACvCM,EAAmC,SAACC,GACpCA,EAAMH,SACRX,EAAeD,IAInBQ,EAAWQ,YAAYF,GAEvBD,EAAUP,KAAK,CAACE,EAAYM,OAGvB,kBAAMD,EAAU1D,SAAQ,wBAAkB8D,4BAChD,IAEIlC,gBAACE,GAASiC,MAAOlB,GAAcD,IAsHtCb,mBAAAA,EACAiC,8BAnHMnB,EAAcjB,aAAiBD,eAEjBE,IAAhBgB,EAQK1B,EAGF0B,GAuGPoB,oBApBqBC,OAEfC,EAAsBvC,cAAiB,SAACI,EAA8BoC,OACpEC,EAAkBtC,EAAsBC,UAEvCJ,gBAACsC,iBAAUE,IAAKA,GAASC,cAGlCF,EAAoBG,iBACQzC,IAA1BqC,EAAUI,0BACQJ,EAAUI,gBACxB,sBAECH"}