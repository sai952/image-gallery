'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var deepMerge = _interopDefault(require('deepmerge'));

function mergeArrays(base, override, helpers) {
  var cloneUnlessOtherwiseSpecified = helpers.cloneUnlessOtherwiseSpecified,
      isMergeableObject = helpers.isMergeableObject; // clone the target array

  var _final = [].concat(base);

  override.forEach(function (overrideItem, index) {
    var baseItem = base[index];

    if (isMergeableObject(overrideItem)) {
      // if we encounter a "mergeable" object, merge it with the base item

      /* eslint-disable @typescript-eslint/no-use-before-define */
      _final[index] = mergeTwo(baseItem, overrideItem);
    } else {
      // otherwise just replace whatever was in the base array with the override
      _final[index] = cloneUnlessOtherwiseSpecified(overrideItem, helpers);
    }
  });
  return _final;
}

function mergeTwo(base, override) {
  return deepMerge(base, override, {
    arrayMerge: mergeArrays
  });
}

function merge(propsObjects) {
  return deepMerge.all(propsObjects, {
    arrayMerge: mergeArrays
  });
}

/**
 * Omits the given keys from the given object
 */
function omit(obj, omittedKeys) {
  // TypeScript assigns the return type, string[] - we are asserting that the return type keyof T
  var allKeys = Object.keys(obj);
  return allKeys.reduce(function (acc, key) {
    // `omittedKeys.indexOf` expects an input of type K extends keyof T
    // `key` is type keyof T, but for some reason TypeScript is freaking out
    // idk.
    var shouldOmit = omittedKeys.indexOf(key) !== -1;

    if (!shouldOmit) {
      // assert that if we got this far, `key` must be one of the keys that _does not_ exist in K
      var keptKey = key;
      acc[keptKey] = obj[keptKey];
    }

    return acc; // assert that the output is exactly Omit<T, K> rather than Partial<Omit<T, K>>
  }, {});
}

// ─── HELPERS ────────────────────────────────────────────────────────────────────
//
// keep track of whether or not we have access to `window` (so that we don't crash during e.g. server-side rendering)

var windowExists = typeof window === 'object'; //
// ─── FACTORY ────────────────────────────────────────────────────────────────────
//

function createResponsiveSystem(screenClassConfiguration) {
  var defaultScreenClass = screenClassConfiguration.defaultScreenClass,
      breakpoints = screenClassConfiguration.breakpoints,
      _screenClassConfigura = screenClassConfiguration.cascadeMode,
      cascadeMode = _screenClassConfigura === void 0 ? 'no-cascade' : _screenClassConfigura; //
  // ─── VALIDATE ───────────────────────────────────────────────────────────────────
  //
  // optimize these error-checks out of production builds

  {
    // todo: validate that defaultScreenClass is defined or that breakpoints is an object?
    // how much should we assume based on our Types?
    var breakpointValues = Object.values(breakpoints);

    if (breakpointValues.length < 2) {
      throw new Error('ScreenClassConfigurationError - `breakpoints` must have at least 2 keys e.g. `{ mobile: 320, desktop: Infinity }`');
    }

    if (breakpointValues.filter(function (value) {
      return value === Infinity;
    }).length !== 1) {
      throw new Error('ScreenClassConfigurationError - `breakpoints` must have exactly 1 entry with a value of `Infinity` for the maximum pixel-width e.g. `{ mobile: 320, desktop: Infinity }`');
    }
  } //
  // ─── SORT ───────────────────────────────────────────────────────────────────────
  //
  // sort the screen classes from smallest -> largest (will make it easier to determine the proper screen class given a window-width later)


  var sortedScreenClassBreakpoints = Object.entries(breakpoints).sort(function (_ref, _ref2) {
    var maxPixelWidth1 = _ref[1];
    var maxPixelWidth2 = _ref2[1];
    return maxPixelWidth1 > maxPixelWidth2 ? 1 : 0;
  });
  var sortedScreenClasses = sortedScreenClassBreakpoints.map(function (_ref3) {
    var screenClass = _ref3[0];
    return screenClass;
  });
  /**
   * Mobile-First Screen Classes include the current screen class and all smaller
   *
   * They should be applied smallest to largest
   */

  function getMobileFirstScreenClasses(breakpoint) {
    return sortedScreenClasses.slice(0, sortedScreenClasses.indexOf(breakpoint) + 1);
  }
  /**
   * Desktop-First Screen Classes include the current screen class and all larger
   *
   * They should be applied from largest to smallest
   */


  function getDesktopFirstScreenClasses(breakpoint) {
    return sortedScreenClasses.slice(sortedScreenClasses.indexOf(breakpoint)).reverse();
  } //
  // ─── CONTEXT ────────────────────────────────────────────────────────────────────
  //


  var screenClassContext = React.createContext(undefined); //
  // ─── PROVIDER ───────────────────────────────────────────────────────────────────
  //

  var Provider = screenClassContext.Provider;

  var ScreenClassProvider = function ScreenClassProvider(_ref4) {
    var children = _ref4.children;

    var _React$useState = React.useState(defaultScreenClass),
        screenClass = _React$useState[0],
        setScreenClass = _React$useState[1];

    React.useLayoutEffect(function () {
      if (!windowExists) {
        return;
      } // build the media queries


      var screenClassMediaQueries = sortedScreenClassBreakpoints.map(function (_ref5, index) {
        var screenClass = _ref5[0],
            maxWidthPx = _ref5[1];
        // the minWidth for this screenClass is the maxWidth of the previous breakpoint + 1
        var minWidthPx = index > 0 ? sortedScreenClassBreakpoints[index - 1][1] + 1 : 0;
        var constraints = [];

        if (minWidthPx !== 0) {
          constraints.push("(min-width: " + minWidthPx + "px)");
        }

        if (maxWidthPx !== Infinity) {
          constraints.push("(max-width: " + maxWidthPx + "px)");
        }

        var mediaQuery = constraints.join(' and ');
        var mediaQueryList = window.matchMedia(mediaQuery); // in order to set the correct initial state, we need to immediately check each mql

        if (mediaQueryList.matches) {
          setScreenClass(screenClass);
        }

        return [screenClass, mediaQueryList];
      });
      var listeners = [];
      screenClassMediaQueries.forEach(function (_ref6) {
        var screenClass = _ref6[0],
            mediaQuery = _ref6[1];

        var listener = function listener(event) {
          if (event.matches) {
            setScreenClass(screenClass);
          }
        };

        mediaQuery.addListener(listener);
        listeners.push([mediaQuery, listener]);
      });
      return function () {
        return listeners.forEach(function (_ref7) {
          var mql = _ref7[0],
              l = _ref7[1];
          return mql.removeListener(l);
        });
      };
    }, []);
    return React.createElement(Provider, {
      value: screenClass
    }, children);
  };

  function useScreenClass() {
    var screenClass = React.useContext(screenClassContext);

    if (screenClass === undefined) {
      // optimize this error-check out of production builds
      {
        throw new Error("`useScreenClass` may only be used inside of a ScreenClassProvider. Make sure that you've rendered a ScreenClassProvider above this component your tree (usually folks render ScreenClassProvider near the root of their app). Returning the default screen class.");
      }
    }

    return screenClass;
  }

  function useResponsiveProps(props) {
    var currentScreenClass = React.useContext(screenClassContext);

    if (currentScreenClass === undefined) {
      // optimize this error-check out of production builds
      {
        throw new Error("`useResponsiveProps` may only be used inside of a ScreenClassProvider. Make sure that you've rendered a ScreenClassProvider above this component your tree (usually folks render ScreenClassProvider near the root of their app). Returning the default props with no overrides.");
      } // if there's no screenClassContext, we'll just return the default props with no overrides
    } //
    // ─── DETERMINE PROPS ─────────────────────────────────────────────
    //
    // TypeScript: this is correct, but TS is having trouble confirming that it will be type P


    var baseProps = omit(props, sortedScreenClasses);
    var applicableScreenClasses = [];

    switch (cascadeMode) {
      case 'mobile-first':
        applicableScreenClasses = getMobileFirstScreenClasses(currentScreenClass);
        break;

      case 'desktop-first':
        applicableScreenClasses = getDesktopFirstScreenClasses(currentScreenClass);
        break;

      case 'no-cascade':
      default:
        applicableScreenClasses = [currentScreenClass];
    } // apply each screen class on top of the baseProps
    // the screenClasses should be sorted in the order in which they should be applied
    // e.g. mobile-first should apply smallest -> largest
    // e.g. desktop-first should apply largest -> smallest
    // we assume that the sorting is already done


    var propsToMerge = [baseProps].concat(applicableScreenClasses.map(function (sc) {
      var _props$sc;

      return (_props$sc = props[sc]) != null ? _props$sc : {};
    }));
    return merge(propsToMerge);
  } // Implementation - just forwardRef to everything


  function responsive(Component) {
    // @ts-ignore
    var ResponsiveComponent = React.forwardRef(function (props, ref) {
      var responsiveProps = useResponsiveProps(props);
      return React.createElement(Component, Object.assign({
        ref: ref
      }, responsiveProps));
    });
    ResponsiveComponent.displayName = Component.displayName !== undefined ? "Responsive(" + Component.displayName + ")" : 'ResponsiveComponent';
    return ResponsiveComponent;
  }

  return {
    ScreenClassProvider: ScreenClassProvider,
    useResponsiveProps: useResponsiveProps,
    useScreenClass: useScreenClass,
    responsive: responsive
  };
}

exports.createResponsiveSystem = createResponsiveSystem;
//# sourceMappingURL=react-responsive-system.cjs.development.js.map
